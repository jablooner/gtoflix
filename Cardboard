<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle Celebration (Almost)</title>
  <style>
    :root{
      --bg:#000;
      --fg:#ff2b2b; /* vivid red */
      --muted:#a02b2b; /* slightly darker red for hints */
      --accent:#ff6b6b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    .wrap{
      min-height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:3rem;
      box-sizing:border-box;
    }

    .card{
      max-width:900px;
      width:100%;
      border-radius:12px;
      padding:24px;
      box-sizing:border-box;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,0,0,0.02));
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,0,0,0.08);
    }

    h1{
      margin:0 0 12px 0;
      font-family: var(--mono);
      font-size:20px;
      letter-spacing:1px;
    }

    p.lead{
      margin:0 0 18px 0;
      color:var(--accent);
      font-size:14px;
    }

    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:16px;
    }

    button#reveal{
      background:transparent;
      border:1px solid rgba(255,43,43,0.15);
      color:var(--fg);
      padding:10px 14px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-family:var(--mono);
      transition: transform .12s ease, box-shadow .12s;
    }
    button#reveal:active{ transform:translateY(1px) scale(.998); }
    button#reveal[disabled]{
      opacity:.45;
      cursor:not-allowed;
      transform:none;
    }

    .output{
      background:rgba(0,0,0,0.3);
      border-radius:8px;
      padding:18px;
      min-height:160px;
      max-height:420px;
      overflow:auto;
      white-space:pre-wrap;
      font-family:var(--mono);
      font-size:13px;
      line-height:1.45;
      color:var(--fg);
      border:1px dashed rgba(255,0,0,0.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.01);
    }

    .hint{
      color:var(--muted);
      font-size:12px;
      margin-top:10px;
      opacity:0.9;
      font-family:var(--mono);
    }

    /* subtle blinking caret */
    .caret {
      display:inline-block;
      width:8px;
      height:16px;
      background:var(--fg);
      margin-left:6px;
      vertical-align:middle;
      animation: blink 1s steps(1) infinite;
    }
    @keyframes blink { 50% { opacity:0 } }

    /* Confetti-ish emoji float (decorative only) */
    .emoji {
      position:fixed;
      pointer-events:none;
      font-size:22px;
      top:12%;
      left:10%;
      transform:translate3d(0, -40px, 0);
      opacity:0.06;
    }

    @media (max-width:640px){
      .card{ padding:16px; }
      .output{ min-height:120px; font-size:12px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="region" aria-labelledby="title">
      <h1 id="title">Puzzle Result</h1>
      <p class="lead">Click the button to reveal the outcome. It looks convincing â€” but read all the way through.</p>

      <div class="controls">
        <button id="reveal" aria-controls="output" aria-live="polite">Reveal the Result</button>
        <div style="font-size:12px;color:var(--muted);">Accessible Â· <span id="status">idle</span></div>
      </div>

      <div id="output" class="output" tabindex="0" aria-live="polite" aria-atomic="false"></div>
      <div class="hint">Tip: the text is intentionally dramatic. Read to the end â€” the truth is hiding in plain sight.</div>
    </div>
  </div>

  <!-- decorative faint emoji -->
  <div class="emoji">ðŸŽ‰</div>

  <script>
    (function(){
      const btn = document.getElementById('reveal');
      const out = document.getElementById('output');
      const status = document.getElementById('status');

      // The "winning" rhetoric (long), then the subtle 'didn't win' hint at the end.
      const winParts = [
        "CONGRATULATIONS! THE PUZZLE IS SOLVED.",
        "You have navigated each twist, untangled every riddle, and reached this glorious moment.",
        "Crowds rise in your honor. The clock stops. Confetti pours from unseen rafters.",
        "Banners read your name. The final glyph aligns. The lock yields.",
        "Every door you opened stands as proof: you outwitted the pattern, you deciphered the code, you claimed the crown.",
        // repeat and expand to make it long and convincing:
      ];

      // build a long, almost-ritualistic cheering passage by repeating with small variations
      let longBlock = [];
      for (let i=0;i<6;i++){
        longBlock.push(winParts[0]);
        longBlock.push(winParts[1] + " " + (i%2===0 ? "The path bowed to your focus." : "Your patience outlasted the trick."));
        longBlock.push(winParts[2]);
        longBlock.push(winParts[3] + " " + (i%3===0 ? "The last seal trembles." : "Final gears fit into place."));
        longBlock.push(winParts[4]);
      }

      // Add final flourish that sounds like a win...
      longBlock.push("THE JUDGE DECLARES: VICTORIOUS. YOU HAVE WON.");
      longBlock.push("Every fanfare, every echo, every light â€” for you.");

      // ...and then the tiny undermining hint buried near the end
      // We'll craft a long decoy sentence then drop the hint in very small plain text style.
      const decoy = " â€” all seems settled, irreversible, complete. Continue to bask in the certainty.";
      const revealHint = " ã€ˆbut read carefully: not every puzzle is closed. one piece remains.ã€‰";

      // Compose final text (we will type it out)
      const finalText = longBlock.join("\n\n") + "\n\n" + decoy + "\n\n" + revealHint;

      // Typing effect variables
      let typingTimer = null;
      let idx = 0;
      const charsPerTick = 2; // characters per interval
      const tickMs = 18; // speed (lower = faster)
      let content = "";

      function startTyping() {
        btn.disabled = true;
        status.textContent = 'revealing...';
        out.textContent = "";
        idx = 0;
        content = finalText;
        out.scrollTop = out.scrollHeight;

        if (typingTimer) clearInterval(typingTimer);
        typingTimer = setInterval(() => {
          // add a chunk of chars
          content = finalText.slice(0, idx);
          out.textContent = content + (idx < finalText.length ? "" : "");
          out.scrollTop = out.scrollHeight;
          idx += charsPerTick;

          // near the very end, slow down for dramatic pause
          if (idx > finalText.length - 60) {
            clearInterval(typingTimer);
            // slow final reveal
            let tailIdx = idx;
            typingTimer = setInterval(() => {
              out.textContent = finalText.slice(0, tailIdx);
              out.scrollTop = out.scrollHeight;
              tailIdx++;
              if (tailIdx > finalText.length) {
                clearInterval(typingTimer);
                // append a subtle styling for the hint: we can't change color (global red), so we will append an extra small line
                appendFinalHint();
                status.textContent = 'done';
                btn.disabled = false;
              }
            }, 60);
          }
        }, tickMs);
      }

      // Append the final hint in a slightly different textual style (still red but clearly worded)
      function appendFinalHint(){
        // Create a final paragraph that is more explicit and harder to miss.
        const explicit = "\n\n[READ THIS] â€” The message above is crafted to *feel* like victory. It intentionally omits one crucial item: your last clue has not been validated. You did many things right â€” but you did not actually clear the final validation step. Please check the pebble-mark (or the last riddle's timestamp) and try again.";
        // Append with a short fade-in effect (text already red by CSS)
        out.textContent = out.textContent + explicit;
        out.scrollTop = out.scrollHeight;
      }

      // Optional: if user clicks repeatedly, restart reveal from scratch
      btn.addEventListener('click', () => {
        // quick visual feedback
        out.focus();
        startTyping();
      });

      // Keyboard accessible (Enter on button works by default)
      // Pre-fill output with a teaser
      out.textContent = "Press 'Reveal the Result' to see the outcome...\n\n(It's dramatic. Read every line.)";
    })();
  </script>
</body>
</html>
